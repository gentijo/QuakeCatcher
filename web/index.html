<!doctype html>
<!--

	Project GIO Visualizer
	
	
	More Information: https://github.com/gentijo/QuakeCatcher/wiki

-->
<html>
<head>
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
		body, html {
			background:#fff;
			color:#000;
			padding:0;
			margin:0;
			overflow:hidden;
			font-family:georgia;
			text-align:center;
			height: 100%;
		}
		a {
			color: skyblue
		}
		.container {
			position: relative;
			top: 0px;
			left: 0px;
			border: 1px solid green;
		}
		canvas {
			pointer-events: none;
			z-index: 10;
		}
		#log {
			position: absolute;
			top: 50px;
			text-align: left;
			display: block;
			z-index: 100;
			font-size: 10px;
		}
		#d {
			text-align: center;
			margin: 1em 0 0 0;
			z-index: 0;
			position: absolute;
			width: 100%;
			display: block
		}
		.button {
			background: orange;
			color: #fff;
			padding: 0.2em 0.5em;
			cursor: pointer
		}
		.inactive {
			background: #999;
			color: #eee
		}

		.rule line {
			stroke: #eee;
			shape-rendering: crispEdges;
		}

		.line {
			fill: none;
			stroke: steelblue;
			stroke-width: 1.5px;
		}
		.x { stroke: #CE2626; }
		.y { stroke: #51B863; }
		.z { stroke: #0936AC; }
		#graph {
			position: absolute;
			bottom: 0px;
			right: 0px;
			z-index: 1000;
		}
		.graphs {
			display: block;
		}
	</style>
</head>
<body>
	<pre id="log"></pre>
	<div id="graph">
		<canvas class="graphs" id="chartx" width="200" height="200"></canvas>
		<canvas class="graphs" id="charty" width="200" height="200"></canvas>
		<canvas class="graphs" id="chartz" width="200" height="200"></canvas>
	</div>
	<script src="/socket.io/socket.io.js"></script>
	<script src="/lib/Three.js" type="text/javascript" charset="utf-8"></script>
	<script src="/lib/RequestAnimationFrame.js" type="text/javascript" charset="utf-8"></script>
	<script src="/lib/Stats.js" type="text/javascript" charset="utf-8"></script>
	<script src="/lib/smoothie.js" type="text/javascript" charset="utf-8"></script>
	<script>
		/**
		 Debug Logging
		 **/
		var Logger = function() {
			var logElem = document.getElementById('log');
			var logQueue = [];
			var pageCounter = 0;
			var queueSize = 50;
			var dirty = false;
			
			return {
				log: function() {
					if(!this.enabled) { 
						if(dirty) {
							dirty = false;
							logElem.innerHTML = '';
						}
						return; 
					}
					var mesg = [];
					for (var i=0; i < arguments.length; i++) {
						mesg.push(arguments[i]);
					};
					logQueue.push(mesg.join(','));
					if(logQueue.length > queueSize) {
						logQueue.shift();
					}
					if(pageCounter++%queueSize == 0) {
						dirty = true;
						logElem.innerHTML = logQueue.join('\n');
					}
				},
				pad: function(str, padding) {
					for (var i=0, padded=''; i < padding; padded+=' ', i++);
					return (padded + str).substr(-padding)
				},
				enabled: false
			}
		}();

		/**
		 Create socket to receive data
		 **/
	
		var socket = io.connect('/gio');
		var gioData = { x: 0, y: 0, z: 0 };
		var gioSmooth = { x: 0, y: 0, z: 0 };
		var gioTS = new Date().getTime();
		var samplesPerPage = 50; // How many x,y,z accelerometer readings do we get per second?
		var sampleIntervalTime = Math.floor(1000/samplesPerPage);
		
		socket.on('gio', function (data) {
			if('x' in data && 'y' in data && 'z' in data) {
				gioData.x = -data.x;
				gioData.y = -data.y;
				gioData.z = -data.z;
				gioTS = new Date().getTime();
			}
			updateLines();
			Logger.log(Logger.pad(gioData.x,8), Logger.pad(gioData.x,8), Logger.pad(gioData.x,8));
		}).on('giostatus', function(data) {
			if(data.message) {
				Logger.log('STATUS: ' + data.message);
			}
		})
	
		/**
		 ThreeJS/WebGL code to render visual representation of accelerometer data.
		 **/

		var SCREEN_WIDTH = window.innerWidth;
		var SCREEN_HEIGHT = window.innerHeight;
		var FLOOR = -250;

		var container, stats;

		var camera, scene, webglRenderer, 
			lightMesh, directionalLight, pointLight, spotLight,
			axes;

		var mouseX = 0, mouseY = 0;

		var windowHalfX = window.innerWidth / 2;
		var windowHalfY = window.innerHeight / 2;

		var has_gl = 0;

		var VIEW_ANGLE = 50,
		    ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT,
		    NEAR = 1,
		    FAR = 5000;

		var SHADOW_MAP_WIDTH = 2048, SHADOW_MAP_HEIGHT = 1024;
		var ARROW_THICKNESS = 5;
		var ARROW_LENGTH = 30;
		var CONE_WIDTH = 7;
		var CONE_HEIGHT = 12;
		var CONE_SEGMENTS = 50;
		var ONE_G = 16384; // One G force
		
		var enable3D = true; // TODO: toggle between 3d modes
		var enableGraph = true;

		if(enable3D) {
			document.addEventListener( 'mousemove', onDocumentMouseMove, false );

			init();
			animate();
		}
		
		function init() {
			container = document.createElement( 'div' );
			container.className = 'container'
			document.body.appendChild( container );
			
			scene = new THREE.Scene();

			// CAMERA

			camera = new THREE.PerspectiveCamera(
				VIEW_ANGLE,
				ASPECT,
				NEAR,
				FAR );
			//camera.position.set( 700, 50, 1900);
			camera.position.set( 70, 30, 50);
			scene.add(camera);
			
			// LIGHTS
			var ambient = new THREE.AmbientLight( 0x000000 );
			scene.add( ambient );

			directionalLight = new THREE.DirectionalLight( 0xffffff, 0.5 );
			directionalLight.position.set( 4, 1, 2 ).normalize();
			scene.add( directionalLight );

			pointLight = new THREE.PointLight( 0xffaa33, 0.8 );
			pointLight.position.set( 0, 0, 0 );
			scene.add( pointLight );

			spotLight = new THREE.SpotLight();
			spotLight.position.set(0,1500,1000);
			spotLight.target.position.set(0, 0, 0);
			//spotLight.castShadow = true;
			scene.add(spotLight)

			// light representation
/*
			sphere = new THREE.SphereGeometry( 100, 16, 8, 1 );
			lightMesh = new THREE.Mesh( sphere, new THREE.MeshBasicMaterial( { color: 0xffaa00 } ) );
			lightMesh.scale.set( 0.05, 0.05, 0.05 );
			lightMesh.position = pointLight.position;
			scene.add( lightMesh );
*/
			try {

				webglRenderer = new THREE.WebGLRenderer( { antialias: true, clearAlpha: 1 } );
				webglRenderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );
				webglRenderer.domElement.style.position = "relative";
				webglRenderer.setClearColorHex(0xEEEEEE, 1.0);
			
				container.appendChild( webglRenderer.domElement );
				has_gl = 1;

			}
			catch (e) {
			}

			stats = new Stats();
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.top = '0px';
			stats.domElement.style.zIndex = 100;
			container.appendChild( stats.domElement );
			
			createMeasureScene();
		}
		
		function createMeasureScene() {
			
			var xBox = new THREE.Mesh(new THREE.CubeGeometry(ARROW_LENGTH,ARROW_THICKNESS,ARROW_THICKNESS), new THREE.MeshLambertMaterial({color: 0xCE2626}));
			var yBox = new THREE.Mesh(new THREE.CubeGeometry(ARROW_THICKNESS,ARROW_THICKNESS,ARROW_LENGTH), new THREE.MeshLambertMaterial({color: 0x51B863}));
			var zBox = new THREE.Mesh(new THREE.CubeGeometry(ARROW_THICKNESS,ARROW_LENGTH,ARROW_THICKNESS), new THREE.MeshLambertMaterial({color: 0x0936AC}));
			
			scene.add(xBox);
			scene.add(yBox);
			scene.add(zBox);
			
			var xArrow = new THREE.Mesh(new THREE.CylinderGeometry(0, CONE_WIDTH, CONE_HEIGHT, CONE_SEGMENTS), new THREE.MeshPhongMaterial({color: 0xCE2626}));
			var yArrow = new THREE.Mesh(new THREE.CylinderGeometry(0, CONE_WIDTH, CONE_HEIGHT, CONE_SEGMENTS), new THREE.MeshPhongMaterial({color: 0x51B863}));
			var zArrow = new THREE.Mesh(new THREE.CylinderGeometry(0, CONE_WIDTH, CONE_HEIGHT, CONE_SEGMENTS), new THREE.MeshPhongMaterial({color: 0x0936AC}));

			scene.add(xArrow);
			scene.add(yArrow);
			scene.add(zArrow);

			axes = {
				x: xBox,
				y: yBox,
				z: zBox,
				xArrow: xArrow,
				yArrow: yArrow,
				zArrow: zArrow
			}			

			for(var id in axes) {
				axes[id].matrixAutoUpdate = false;
			}
		}

		function animate() {
			requestAnimationFrame(animate);
			render();
			stats.update();
		}

		function log( text ) {

			var e = document.getElementById( "log" );
			e.innerHTML = text + "<br/>" + e.innerHTML;

		}
				
		var r=0;
		
		function render() {
			var movementMultiplier = .3;
			/*
			if(mouseX && mouseY) {
				camera.position.x += ( mouseX*movementMultiplier - camera.position.x) * .05;
				camera.position.y += ( - mouseY*movementMultiplier - camera.position.y) * .05;
			}*/
			
			camera.position.x += ( gioSmooth.x*0.003 - camera.position.x) * 0.05;
			camera.position.y += ( gioSmooth.z*0.003 - camera.position.y) * 0.05;
			
			camera.lookAt(scene.position);

			//lightMesh.position.x = 700 * Math.cos(r);
			//lightMesh.position.z = 700 * Math.sin(r);
			pointLight.position.set(camera.position.x, camera.position.y, camera.position.z);

			if(new Date().getTime() - gioTS > 200 && false) {
				// TODO: Determine smoothing function
				axes.x.scale.x = Math.max(axes.x.scale.x-0.01,0);
				axes.y.scale.y = Math.max(axes.y.scale.y-0.01,0);
				axes.z.scale.z = Math.max(axes.z.scale.z-0.01,0);
			} else {
				axes.x.position.x = gioSmooth.x/ONE_G * (ARROW_LENGTH/2 - ARROW_THICKNESS / 2);
				axes.xArrow.visible = (Math.abs(gioSmooth.x/ONE_G) > 0.1);
				axes.xArrow.position.x = axes.x.position.x + ((gioSmooth.x < 0)?-1:1) * (ARROW_LENGTH/2 + CONE_HEIGHT/2);
				axes.xArrow.rotation.z = ((gioSmooth.x < 0)?1:-1) * Math.PI / 2;
				
				axes.y.position.z = gioSmooth.y / ONE_G * (ARROW_LENGTH/2 - ARROW_THICKNESS / 2);
				axes.yArrow.visible = (Math.abs(gioSmooth.y/ONE_G) > 0.1);
				axes.yArrow.position.z = axes.y.position.z + ((gioSmooth.y < 0)?-1:1) * (ARROW_LENGTH/2 + CONE_HEIGHT/2);
				axes.yArrow.rotation.x = ((gioSmooth.y < 0)?-1:1) * Math.PI / 2;

				axes.z.position.y = gioSmooth.z / ONE_G * (ARROW_LENGTH/2 - ARROW_THICKNESS / 2);
				axes.zArrow.visible = (Math.abs(gioSmooth.z/ONE_G) > 0.1);
				axes.zArrow.position.y = axes.z.position.y + ((gioSmooth.z < 0)?-1:1) * (ARROW_LENGTH/2 + CONE_HEIGHT/2);
				axes.zArrow.rotation.z = ((gioSmooth.z < 0)?-1:-2) * Math.PI;
			}

			for(var id in axes) {
				axes[id].updateMatrix();
			}
			
			r+=0.01

			webglRenderer.render(scene, camera);
		}
		
		function onDocumentMouseMove(event) {
			mouseX = (event.clientX - windowHalfX);
			mouseY = (event.clientY - windowHalfY);
		}
	</script>
	
	<script type="text/javascript" charset="utf-8">
	// Stats utilities
	var Stats = {};
	Stats.StandardDeviation = function(arr) {
		var avg = Stats.mean(arr);
		var squares = 0;
		for (var i=0; i < arr.length; i++) {
			squares += Math.pow(arr[i] - avg, 2);
		}
		return Math.sqrt(squares / arr.length);
	}
	
	Stats.mean = function(arr) {
		for (var i=0, sum=0; i < arr.length; sum += arr[i++]);
		return sum/arr.length;
	}

	if(enableGraph) {
		var smoothieOptions = {
			fps: 60,
			interpolation: "line",
			grid: { fillStyle: 'rgba(255,255,255,0)', strokeStyle: 'rgba(20,20,20, 0.1)', lineWidth: 1, millisPerLine: 1000, verticalSections: 0 },
			labels: { fillStyle: 'rgb(20,20,20)' }
		};
		var smoothieX = new SmoothieChart(smoothieOptions);
		var smoothieY = new SmoothieChart(smoothieOptions);
		var smoothieZ = new SmoothieChart(smoothieOptions);

		var timeLineOptions = {
			resetBoundsInterval: 500
		}
		
		TimeSeries.prototype.resetBounds = function() {
			var range = 0.1;
			for (var i=0, sum=0; i < this.data.length; sum += this.data[i++][1]);
			var mean = sum/this.data.length
			this.minValue = (mean-range);
			this.maxValue = (mean+range);
		}

		TimeSeries.prototype.append = function(timestamp, value) {
		  this.data.push([timestamp, value]);
		}
		
		var xLine = new TimeSeries(timeLineOptions);
		var yLine = new TimeSeries(timeLineOptions);
		var zLine = new TimeSeries(timeLineOptions);

		smoothieX.addTimeSeries(xLine, { strokeStyle: '#CE2626', lineWidth: 1 });
		smoothieY.addTimeSeries(yLine, { strokeStyle: '#51B863', lineWidth: 1 });
		smoothieZ.addTimeSeries(zLine, { strokeStyle: '#0936AC', lineWidth: 1 });
		
		function smooth(data, filterValue, smoothValue) {
			return (data*(1-filterValue) + smoothValue*filterValue);
		}
		
		var axesSamples = [[],[],[]];
		var sampleSize = 50;
		
		// STD Deviation threshold constant
		var DEVIATION_THRESHOLD = 4;
		
		function checkSample(x, y, z) {
			var maxDeviation = 0;
			for (var i=0; i < axesSamples.length; i++) {
				axesSamples[i].push(arguments[i]);
				if(axesSamples[i].length > sampleSize) {
					axesSamples[i].shift();
				}
				var stdDev = Stats.StandardDeviation(axesSamples[i]);
				var mean = Stats.mean(axesSamples[i]);
				var deviation = Math.abs(arguments[i] - mean) / stdDev;
				if(deviation > maxDeviation) {
					maxDeviation = deviation;
				}
			}
			if(maxDeviation > DEVIATION_THRESHOLD) {
				console.log('QUAKE', maxDeviation);
			}
			return maxDeviation;
		}
		
		function updateLines() {
			var filterValue = 0.9;
			gioSmooth.x = smooth(gioData.x, filterValue, gioSmooth.x);
			gioSmooth.y = smooth(gioData.y, filterValue, gioSmooth.y);
			gioSmooth.z = smooth(gioData.z, filterValue, gioSmooth.z);

			checkSample(gioSmooth.x, gioSmooth.y, gioSmooth.z);

			xLine.append(new Date().getTime(), gioData.x/ONE_G);
			yLine.append(new Date().getTime(), gioData.y/ONE_G);
			zLine.append(new Date().getTime(), gioData.z/ONE_G);
		}
		smoothieX.streamTo(document.getElementById('chartx'), sampleIntervalTime);
		smoothieY.streamTo(document.getElementById('charty'), sampleIntervalTime);
		smoothieZ.streamTo(document.getElementById('chartz'), sampleIntervalTime);
		
		function onResize() {
			document.getElementById('chartx').height = window.innerHeight / 3;
			document.getElementById('charty').height = window.innerHeight / 3;
			document.getElementById('chartz').height = window.innerHeight / 3;
		}
		
		window.addEventListener('resize', onResize, false);
		onResize();
	}
	</script>
</body>
</html>