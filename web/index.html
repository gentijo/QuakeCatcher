<!doctype html>
<!--

	Project GIO Visualizer
	
	
	More Information: https://github.com/gentijo/QuakeCatcher/wiki

-->
<html>
<head>
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
		body, html {
			background:#fff;
			color:#000;
			padding:0;
			margin:0;
			overflow:hidden;
			font-family:georgia;
			text-align:center;
			height: 100%;
		}
		a {
			color: skyblue
		}
		.container {
			position: relative;
			top: 0px;
			left: 0px;
			border: 1px solid green;
		}
		canvas {
			pointer-events: none;
			z-index: 10;
			position: absolute;
			top: 0px;
			left: 0px;
		}
		#log {
			position: absolute;
			top: 50px;
			text-align: left;
			display: block;
			z-index: 100
		}
		#d {
			text-align: center;
			margin: 1em 0 0 0;
			z-index: 0;
			position: absolute;
			width: 100%;
			display: block
		}
		.button {
			background: orange;
			color: #fff;
			padding: 0.2em 0.5em;
			cursor: pointer
		}
		.inactive {
			background: #999;
			color: #eee
		}

		.rule line {
			stroke: #eee;
			shape-rendering: crispEdges;
		}

		.line {
			fill: none;
			stroke: steelblue;
			stroke-width: 1.5px;
		}
		.x { stroke: #CE2626; }
		.y { stroke: #51B863; }
		.z { stroke: #0936AC; }
		#graph {
			position: absolute;
			bottom: 0px;
			z-index: 1000;
			height: 300px;
		}
	</style>
</head>
<body>
	<pre id="log"></pre>
	<div id="graph">
		<canvas id="chart" width="1000" height="300"></canvas>
	</div>
	<script src="/socket.io/socket.io.js"></script>
	<script src="/lib/Three.js" type="text/javascript" charset="utf-8"></script>
	<script src="/lib/RequestAnimationFrame.js" type="text/javascript" charset="utf-8"></script>
	<script src="/lib/Stats.js" type="text/javascript" charset="utf-8"></script>
	<script src="/lib/smoothie.js" type="text/javascript" charset="utf-8"></script>
	<script>
		/**
		 Create socket to receive data
		 **/
	
		var socket = io.connect('/gio');
		var gioData = { x: 0, y: 0, z: 0 };
		var gioSmooth = { x: 0, y: 0, z: 0 };
		var gioTS = new Date().getTime();

		socket.on('gio', function (data) {
			//console.log(data);
			if(data.x && data.y && data.z) {
				gioData.x = -data.x;
				gioData.y = -data.y;
				gioData.z = -data.z;
				gioTS = new Date().getTime();
			}
		});
	
		/**
		 ThreeJS/WebGL code to render visual representation of accelerometer data.
		 **/

		var SCREEN_WIDTH = window.innerWidth;
		var SCREEN_HEIGHT = window.innerHeight;
		var FLOOR = -250;

		var container, stats;

		var camera, scene, webglRenderer, 
			lightMesh, directionalLight, pointLight, spotLight,
			axes;

		var mouseX = 0, mouseY = 0;

		var windowHalfX = window.innerWidth / 2;
		var windowHalfY = window.innerHeight / 2;

		var has_gl = 0;

		var VIEW_ANGLE = 23,
		    ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT,
		    NEAR = 5,
		    FAR = 3000;

		var SHADOW_MAP_WIDTH = 2048, SHADOW_MAP_HEIGHT = 1024;
		var ARROW_THICKNESS = 50;
		var ARROW_LENGTH = 300;
		var CONE_WIDTH = 72;
		var CONE_HEIGHT = 120;
		var ONE_G = 16384; // One G force
		
		var enable3D = true; // TODO: toggle between 3d modes
		var enableGraph = true;

		if(enable3D) {
			document.addEventListener( 'mousemove', onDocumentMouseMove, false );

			init();
			animate();
		}
		
		function init() {
			container = document.createElement( 'div' );
			container.className = 'container'
			document.body.appendChild( container );
			
			scene = new THREE.Scene();

			// CAMERA

			camera = new THREE.PerspectiveCamera(
				VIEW_ANGLE,
				ASPECT,
				NEAR,
				FAR );
			camera.position.set( 700, 50, 1900);
			scene.add(camera);
			
			// LIGHTS

			var ambient = new THREE.AmbientLight( 0x444444 );
			scene.add( ambient );

			directionalLight = new THREE.DirectionalLight( 0xffffff, 0.5 );
			directionalLight.position.set( 1, 1, 2 ).normalize();
			scene.add( directionalLight );

			pointLight = new THREE.PointLight( 0xffaa00, 0.8 );
			pointLight.position.set( 0, 0, 0 );
			scene.add( pointLight );

			spotLight = new THREE.SpotLight();
			spotLight.position.set(0,1500,1000);
			spotLight.target.position.set(0, 0, 0);
			spotLight.castShadow = true;
			scene.add(spotLight)

			// light representation
			sphere = new THREE.SphereGeometry( 100, 16, 8, 1 );
			lightMesh = new THREE.Mesh( sphere, new THREE.MeshBasicMaterial( { color: 0xffaa00 } ) );
			lightMesh.scale.set( 0.05, 0.05, 0.05 );
			lightMesh.position = pointLight.position;
			scene.add( lightMesh );

			try {

				webglRenderer = new THREE.WebGLRenderer( { antialias: true, clearAlpha: 1 } );
				webglRenderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );
				webglRenderer.domElement.style.position = "relative";
				webglRenderer.setClearColorHex(0xEEEEEE, 1.0);
				
				container.appendChild( webglRenderer.domElement );
				has_gl = 1;

			}
			catch (e) {
			}

			stats = new Stats();
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.top = '0px';
			stats.domElement.style.zIndex = 100;
			container.appendChild( stats.domElement );
			
			createMeasureScene();
		}
		
		function createMeasureScene() {
			
			var xBox = new THREE.Mesh(new THREE.CubeGeometry(ARROW_LENGTH,ARROW_THICKNESS,ARROW_THICKNESS), new THREE.MeshLambertMaterial({color: 0xCE2626}));
			var yBox = new THREE.Mesh(new THREE.CubeGeometry(ARROW_THICKNESS,ARROW_THICKNESS,ARROW_LENGTH), new THREE.MeshLambertMaterial({color: 0x51B863}));
			var zBox = new THREE.Mesh(new THREE.CubeGeometry(ARROW_THICKNESS,ARROW_LENGTH,ARROW_THICKNESS), new THREE.MeshLambertMaterial({color: 0x0936AC}));
			
			scene.add(xBox);
			scene.add(yBox);
			scene.add(zBox);
			
			var xArrow = new THREE.Mesh(new THREE.CylinderGeometry(0, CONE_WIDTH, CONE_HEIGHT, 50, 50), new THREE.MeshLambertMaterial({color: 0xCE2626}));
			var yArrow = new THREE.Mesh(new THREE.CylinderGeometry(0, CONE_WIDTH, CONE_HEIGHT, 50, 50), new THREE.MeshLambertMaterial({color: 0x51B863}));
			var zArrow = new THREE.Mesh(new THREE.CylinderGeometry(0, CONE_WIDTH, CONE_HEIGHT, 50, 50), new THREE.MeshLambertMaterial({color: 0x0936AC}));

			scene.add(xArrow);
			scene.add(yArrow);
			scene.add(zArrow);

			axes = {
				x: xBox,
				y: yBox,
				z: zBox,
				xArrow: xArrow,
				yArrow: yArrow,
				zArrow: zArrow
			}			
		}

		function animate() {
			requestAnimationFrame(animate);
			render();
			stats.update();
		}

		function log( text ) {

			var e = document.getElementById( "log" );
			e.innerHTML = text + "<br/>" + e.innerHTML;

		}
				
		var r=0;
		
		function render() {
			var movementMultiplier = 3;
			
			camera.position.x += ( mouseX*movementMultiplier - camera.position.x) * .05;
			camera.position.y += ( - mouseY*movementMultiplier - camera.position.y) * .05;
			
			camera.lookAt(scene.position);

			lightMesh.position.x = 700 * Math.cos(r);
			lightMesh.position.z = 700 * Math.sin(r);

			if(new Date().getTime() - gioTS > 200 && false) {
				// TODO: Determine smoothing function
				axes.x.scale.x = Math.max(axes.x.scale.x-0.01,0);
				axes.y.scale.y = Math.max(axes.y.scale.y-0.01,0);
				axes.z.scale.z = Math.max(axes.z.scale.z-0.01,0);
			} else {
				axes.x.position.x = gioSmooth.x/ONE_G * (ARROW_LENGTH/2 - ARROW_THICKNESS / 2);
				axes.xArrow.visible = (Math.abs(gioSmooth.x/ONE_G) > 0.1);
				axes.xArrow.position.x = axes.x.position.x + ((gioSmooth.x < 0)?-1:1) * (ARROW_LENGTH/2 + CONE_HEIGHT/2);
				axes.xArrow.rotation.z = ((gioSmooth.x < 0)?1:-1) * Math.PI / 2;
				
				axes.y.position.z = gioSmooth.y / ONE_G * (ARROW_LENGTH/2 - ARROW_THICKNESS / 2);
				axes.yArrow.visible = (Math.abs(gioSmooth.y/ONE_G) > 0.1);
				axes.yArrow.position.z = axes.y.position.z + ((gioSmooth.y < 0)?-1:1) * (ARROW_LENGTH/2 + CONE_HEIGHT/2);
				axes.yArrow.rotation.x = ((gioSmooth.y < 0)?-1:1) * Math.PI / 2;

				axes.z.position.y = gioSmooth.z / ONE_G * (ARROW_LENGTH/2 - ARROW_THICKNESS / 2);
				axes.zArrow.visible = (Math.abs(gioSmooth.z/ONE_G) > 0.1);
				axes.zArrow.position.y = axes.z.position.y + ((gioSmooth.z < 0)?-1:1) * (ARROW_LENGTH/2 + CONE_HEIGHT/2);
				axes.zArrow.rotation.z = ((gioSmooth.z < 0)?-1:-2) * Math.PI;
			}
			
			r+=0.01

			webglRenderer.render(scene, camera);
		}
		
		function onDocumentMouseMove(event) {
			mouseX = (event.clientX - windowHalfX);
			mouseY = (event.clientY - windowHalfY);
		}
	</script>
	
	<<script type="text/javascript" charset="utf-8">
	// Stats utilities
	var Stats = {};
	Stats.StandardDeviation = function(arr) {
		var avg = Stats.mean(arr);
		var squares = 0;
		for (var i=0; i < arr.length; i++) {
			squares += Math.pow(arr[i] - avg, 2);
		}
		return Math.sqrt(squares / arr.length);
	}
	
	Stats.mean = function(arr) {
		for (var i=0, sum=0; i < arr.length; sum += arr[i++]);
		return sum/arr.length;
	}

	if(enableGraph) {
		var smoothie = new SmoothieChart({
			minValue: -1.5,
			maxValue: 1.5,
			grid: { fillStyle: 'rgba(255,255,255,0)', strokeStyle: 'rgba(0,0,0,0.1)', lineWidth: 1, millisPerLine: 1000, verticalSections: 2 },
			labels: { fillStyle: 'rgba(0,0,0,0.5)' }
		});
		var xLine = new TimeSeries();
		var yLine = new TimeSeries();
		var zLine = new TimeSeries();

		smoothie.addTimeSeries(xLine, { strokeStyle: '#CE2626', lineWidth: 1 });
		smoothie.addTimeSeries(yLine, { strokeStyle: '#51B863', lineWidth: 1 });
		smoothie.addTimeSeries(zLine, { strokeStyle: '#0936AC', lineWidth: 1 });
		
		var xSmooth = new TimeSeries();
		var ySmooth = new TimeSeries();
		var zSmooth = new TimeSeries();

		smoothie.addTimeSeries(xSmooth, { strokeStyle: '#801818', lineWidth: 2 });
		smoothie.addTimeSeries(ySmooth, { strokeStyle: '#367C42', lineWidth: 2 });
		smoothie.addTimeSeries(zSmooth, { strokeStyle: '#06216A', lineWidth: 2 });

		function smooth(data, filterValue, smoothValue) {
			return (data*(1-filterValue) + smoothValue*filterValue);
		}
		
		var axesSamples = [[],[],[]];
		var sampleSize = 50;
		
		// STD Deviation threshold constant
		var DEVIATION_THRESHOLD = 4;
		
		function checkSample(x, y, z) {
			var maxDeviation = 0;
			for (var i=0; i < axesSamples.length; i++) {
				axesSamples[i].push(arguments[i]);
				if(axesSamples[i].length > sampleSize) {
					axesSamples[i].shift();
				}
				var stdDev = Stats.StandardDeviation(axesSamples[i]);
				var mean = Stats.mean(axesSamples[i]);
				var deviation = Math.abs(arguments[i] - mean) / stdDev;
				if(deviation > maxDeviation) {
					maxDeviation = deviation;
				}
			}
			if(maxDeviation > DEVIATION_THRESHOLD) {
				console.log('QUAKE', maxDeviation);
			}
			return maxDeviation;
		}
		
		function updateLines() {
			var filterValue = 0.9;
			gioSmooth.x = smooth(gioData.x, filterValue, gioSmooth.x);
			gioSmooth.y = smooth(gioData.y, filterValue, gioSmooth.y);
			gioSmooth.z = smooth(gioData.z, filterValue, gioSmooth.z);

			checkSample(gioSmooth.x, gioSmooth.y, gioSmooth.z);
			
			xSmooth.append(new Date().getTime(), gioSmooth.x/ONE_G);
			ySmooth.append(new Date().getTime(), gioSmooth.y/ONE_G);
			zSmooth.append(new Date().getTime(), gioSmooth.z/ONE_G);
			
			xLine.append(new Date().getTime(), gioData.x/ONE_G);
			yLine.append(new Date().getTime(), gioData.y/ONE_G);
			zLine.append(new Date().getTime(), gioData.z/ONE_G);
		}
		setInterval(updateLines, 50);
		smoothie.streamTo(document.getElementById('chart'), 50);

		function onResize() {
			document.getElementById('chart').width = window.innerWidth;
		}
		
		onResize();
		window.addEventListener('resize', onResize, false);
	}
	</script>>
</body>
</html>